Описание:
=========

Что это?
--------

Данная программа представляет собой транслятор из машинных команд в
бинарные (опционально – восьмеричные) коды для ручного ввода в
лабораторный стенд с однокристальным 8-разрядным МП КР580ВМ80А.

Как этим пользоваться?
----------------------

### Что для этого нужно?

Итак, для успешного запуска необходимы:

-   Компьютер с ОС Linux;

-   Программа yacc (тестировалось на GNU Bison);

-   Программа lex (тестировалось на Flex).

Перечисленные программы, скорее всего, обсуждались в пятом семестре в
курсе транслирующих систем и не должны вызывать затруднений. Для
установки можно воспользоваться следующими консольными командами:

sudo apt-get update

sudo apt-get install flex

sudo apt-get install bison

which flex /\*Sanity check to make sure flex is installed\*/

which bison /\*Sanity check to make sure bison is installed\*/

### Как это запустить?

Итак, у Вас установлены все программы, а проект скачан с репозитория.
Далее в терминале переходим в папку проекта (MP Project) и вводим:

./build

Запуск собранного транслятора осуществляется командой:

./generated/run

В качестве аргументов можно (и рекомендуется) указывать текстовые файлы
с программой.

Также при вызове транслятора можно использовать ключи –opnames и –octal.
Первый добавляет короткую подсказку по вводимым командам, второй –
изменяет формат вывода на восьмеричное представление.

Что писать во входном файле?
----------------------------

Как ранее говорилось, входной файл представляет собой набор
ассемблеро-подобных команд, следующих друг за другом на новой строке
либо отделенных пробелами. Например:

![](media/image1.png){width="4.627635608048994in"
height="2.116279527559055in"}

Также здесь нужно отметить, что транслятор поддерживает комментарии в
стиле Си:

-   /\*comment\*/

-   //comment

### А что-то еще туда можно записывать?

Конечно, можно.

Первое, и самое важное: поддерживаются префиксы для систем счисления.
Система счисления по умолчанию – десятичная. Учитывайте это при
написании программ. Остальные поддерживаемые префиксы:

-   b – binary, двоичная;

-   o – octal, восьмеричная;

-   h – hexadecimal, 16-ричная;

-   d – decimal, десятичная (префикс не обязателен, используется
    по умолчанию).

Также поддерживаются все арифметические операции из языка Си (вплоть до
сдвигов, деления по модулю, инкремента и всего остального).

Пример входного файла к этим пунктам:

![](media/image2.png){width="1.6513888888888888in" height="1.41875in"}

Внимание: при вводе аргумента, большего 11 111 111~2~ = 255~10~,
возможны (и скорее всего возникнут) ошибки трансляции.

Арифметические операции удобны при формировании 2-10 числа, как то:

![](media/image3.png){width="2.135715223097113in"
height="0.7709405074365704in"}

### А что-то еще из полезного?

Да, в качестве экспериментальной фичи были частично добавлены метки.
Почему частично? Потому что в рамках однопроходного транслятора было
сложно реализовать предописание метки (ссылку на нее) до ее фактического
появления в программе.

Итого: можно описать метку, ПОСЛЕ чего в коде ссылаться на нее. То есть
переходы по меткам возможны только «вверх». Пример:

![](media/image4.png){width="1.2909722222222222in"
height="0.8486111111111111in"}

Фактически метка «запоминает» адрес следующей за ней команды, и при
использовании происходит подстановка этого значения вместо имени метки.

Если Вы хотите ссылаться на метку, описанную далее по тексту программы,
это можно сделать в полуавтоматическом режиме: Вы описываете метку
(ключевой символ – «&gt;») и заносите любое значение в поле адреса
команды перехода, после чего выполняете трансляцию программы. В
консольном выводе Вы увидите адреса обнаруженных транслятором меток,
после чего их можно подставить вручную в поле адреса перехода.

Помимо прочего транслятор также выполняет минимальный анализ входных
данных и выдает диагностические сообщения, что облегчает поиск ошибок в
разработанной программе.
